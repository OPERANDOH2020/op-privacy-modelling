## Tutorial: Auto-generation of transitions and states

### State Labels
The LTS is extended so that each state node has a label that represents
the state of privacy. This is in terms of state variables concerning
the roles and the data fields. For each role/field pair there are two
boolean values:
* **hasSeen**: The role has seen the value of this field.
* **canSee**: The role has the privileges to view this field and could see the
value in the future.

This table for a single data field (name)
and two roles (doctor and nurse) can be visualised as follows:

```
+----------------+------------+------------+
|      Field     |   doctor   |   nurse    |
+----------------+------------+------------+
|  patient.name  |   f | f    |   f | f    |
+----------------+------------+------------+
```
For two fields it would be (here the doctor can see both fields but hasn't yet,
and the nurse can see both fields and has seen patient.name):

```
+------------------+------------+------------+
|      Field       |   doctor   |   nurse    |
+------------------+------------+------------+
|   patient.name   |   t | f    |   t | t    |
|  patient.weight  |   t | f    |   t | f    |
+------------------+------------+------------+
```


### LTS generation
To generate an LTS we take a data flow specification and then add access control
policies. These policies are defined in JSON as follows:


```json
{
   "policy_text":"test one",
   "policy_url":"testOne",

   "policies":[
      {
         "subject":"doctor",
         "permission":true,
         "action":"Access",
         "resource":"patient.name"
      },
      {
         "subject":"nurse",
         "permission":true,
         "action":"Access",
         "resource":"patient.name"
      }
   ]
}
```

We can then run new algorithms to take the LTS statemachine created from the
XML specification and from that generate a new LTS modelling potential actions
that could further happen to the data. The following Java code shows how this
is performed:

```java
public static void main(String[] args) {
        String sMachine = null;

        /**
         * Get the data flow XML model document
         */
        try {
            sMachine = FileUtils.readFile(FILENAME, Charset.defaultCharset());
        } catch (IOException ex) {
            System.err.println("Error Reading file" +  FILENAME);
            System.err.println("Error:" +  ex.getMessage());
        }
        
        /**
         * Build a data flow directed graph and visualize
         */
        StateMachine stateMachine = new StateMachine();
        stateMachine.buildDataFlowLTS(sMachine);

        /**
         * Add the access policies
         */
        stateMachine.addAccessPolicies("unittests/oneTransition.json");
        AccessPolicyModelGeneration gModel = new AccessPolicyModelGeneration();
        try {
            gModel.generateStates(stateMachine);
            stateMachine.visualiseAutomatedGraph(true);
        } catch (InvalidStateMachineException ex) {
            System.err.println("Error generating new states automatically - " + ex.getMessage());
        }
    }
```

There are three new programming elements to identify here:
* **addAccessPolicies** adds the access policy information to the base state machine.
* **AccessPolicyModelGeneration**: is the class of methods to perform model transformation with the new generated 
states based upon the access policies.
* **stateMachine.visualiseAutomatedGraph(true)**: creates a visualisation with the new states and importantly adds the state variable
labels to the model.

This will then generate the following visualisation of the autogenerated data flow:

![Data flow visualisation output][viz2] 

### Further code information 
The AccessPolicyModelGeneration class has the important methods to run algorithms
on the state machine. Note, all classes to do with the state machine are in
the package: **uk.ac.soton.itinnovation.modelmyprivacy.lts**

The following is the pre-order traversal of the data-flow state machine. We
assume that data-flows have no need for loops.
```java
/**
     * Perform a pre order traversal of the data flow directed graph. As
     * it is a data flow model we assume there are no loops. If a loop is
     * mistakenly input then this traversal method will fail.
     *
     * @param node The start node of the data flow model
     * @param states The map to store the created states in.
     */
    private void preorderTraversal(State node, StateMachine dataFlowModel) throws InvalidStateMachineException {
        // Display the label of the data flow node current position
        System.out.println(node.getLabel());

        // Iterate over the outgoing transitions
        Iterator iter = node.getTransitions().iterator();
        while (iter.hasNext()) {
            Transition toProduce = (Transition) iter.next();
            /**
             * Based on the transition generate the automated states.
             */
            String action = toProduce.getLabel().getAction();
            switch (action) {
                case "create":
                    State createdNode = generateStateFromCreateAction(toProduce, (StateNode) node, dataFlowModel);

                    break;
                case "access":
                    // change the seen state variables of nodes that exist
                    State accessNode = generateStateFromAccessAction(toProduce, (StateNode) node, dataFlowModel);
            }
            preorderTraversal(dataFlowModel.getState(toProduce.readToLabel()), dataFlowModel);
        }
    }
```
The code only currenly works on create and access actions. Significant work is required to consider how to autogenerate
based upon other actions in the data flow.

[viz2]: src/main/resources/images/visual1.png "Data flow visualisation"